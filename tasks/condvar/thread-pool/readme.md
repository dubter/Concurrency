# Static Thread Pool

В этой задаче мы построим базовый инфраструктурный компонент для параллельного исполнения задач – _пул потоков_ (_thread pool_).

Наш пул потоков будет _статическим_ – число потоков фиксируется при создании пула и не меняется до остановки пула.

Далее с потоками и параллельностью мы будем работать только через пулы.

## Схема работы

![Thread pool](images/thread_pool.png)

## Конструктор

```cpp
// Создаем пул из 4-х потоков
tp::StaticThreadPool pool{/*workers=*/4, /*name=*/"example"};
```

## `Submit`

Пул потоков исполняет [задачи](tp/task.hpp) – функции без аргументов и возвращаемого значения.

Запланировать задачу на исполнение в пуле можно с помощью метода `Submit`:

```cpp
tp::StaticThreadPool pool{4, "example"};

pool.Submit([]() {
  std::cout << "Hello from pool!" << std::endl;
});
```

Вызов `Submit` не дожидается завершения задачи, он лишь планирует ее на исполнение (т.е. добавляет в очередь задач) после чего возвращает управление.

### `Current`

Иногда хочется отправить новую задачу в пул из прямо из бегущей задачи, т.е. из потока пула. 

Для этого нам пригодится свободная функция `tp::Current()`, которая возвращает указатель на текущий пул, если ее вызвали из потока-воркера, и `nullptr` в противном случае.

```cpp
tp::StaticThreadPool pool{4, "example"};

pool.Submit([]() {
  // Планируем задачу из задачи
  tp::Current()->Submit([]() {
    std::cout << "Works!" << std::endl;
  });
});
```

## Остановка

Пул должен быть остановлен явно до своего разрушения с помощью вызова метода `Join` либо `Shutdown`.

Пользователь пула должен вызвать только один из этих методов и только один раз, в противном случае – UB.

Опоздавшие `Submit`-ы будут игнорироваться пулом.

### `Join`

С помощью метода `Join` можно дождаться завершения работы в пуле и остановить потоки-воркеры:

```cpp
tp::StaticThreadPool pool{4, "example"};

for (size_t i = 0; i < 100500; ++i) {
  pool.Submit([]() {
     // ...
  });
}

// Ждем завершения 100500 задач
pool.Join();
```

С момента вызова `Join` пул работает до тех пор, пока в нем остается работа, т.е. пока счетчик запланированных задач не опустился до нуля, после чего очередь задач закрывается и воркеры останавливаются.

В частности, в следующем примере будут выполнены обе задачи:

```cpp
tp::StaticThreadPool pool{4, "example"};

pool.Submit([]() {
  // Спим 1 секунду
  // Не делайте так в пуле потоков!
  std::this_thread::sleep_for(1s);
  // К этому моменту уже вызван pool.Join()
  tp::Current()->Submit([]() {
    std::cout << "Works!" << std::endl;
  });
});

// На момент вызова Join вторая задача еще не запланирована,
// но она будет исполнена
pool.Join();
```

### `Shutdown`

Жесткая остановка – выбрасываем запланированные, но еще не запустившиеся задачи и останавливаем потоки-воркеры.

## Имена потоков

Если в программе несколько пулов, то полезно уметь проверять, что текущая задача исполняется в правильном пуле.

Для этого мы будем 
- маркировать потоки-воркеры именем пула с помощью функции `LabelThread(name)`,
- проверять эти метки с помощью функции `ExpectThread(name)`.

```cpp
tp::StaticThreadPool pool{4, "example"};

pool.Submit([]() {
  // Паникуем если оказались в другом пуле
  tp::ExpectThread("example");
});
```

## Очередь

Для распределения задач между потоками пула будем использовать общую блокирующую очередь неограниченной емкости – `UnboundedBlockingQueue`.

### API

| Метод | Семантика |
|---|---|
| `bool Put(T value)` | Если очередь еще не закрыта (`Close`, `Cancel`), то положить в нее `value` и вернуть `true`, в противном случае вернуть `false` |
| `std::optional<T> Take()` | Дождаться и извлечь элемент из головы очереди; если же очередь закрыта и пуста, то вернуть `std::nullopt` |
| `void Close()` | Закрыть очередь для новых `Put`-ов, уже добавленные в очередь элементы будут доступны для извлечения |
| `void Cancel()` | Закрыть очередь для новых `Put`-ов и выбросить все неизвлеченные элементы

### Bounded vs Unbounded

Обратите внимание: пулу потоков нужна очередь именно неограниченной емкости.

Придумайте сценарий дедлока в пуле с очередью, которая блокирует поток-продьюсер при переполнении буфера.


## Замечания

### Возврат значения / ошибки, зависимости

- Метод `Submit` в пуле не предполагает никакого механизма возврата значения или ошибки из задачи.

- Пул потоков не дает возможности задать зависимости между планируемыми задачами.

И то, и другое, безусловно, полезно. Но в нашем пуле потоков ничего этого не будет, он останется максимально простым.

Требуемая функциональность (возврат результата, планирование задач с учетом завимостей) будет достигнута с помощью отдельных инструментов / абстракций, которые будут хорошо комбинироваться с пулом потоков, но при этом будут ортогональны ему.

### Unified Executors

Посмотрите на `static_thread_pool` из [A Unified Executors Proposal for C++](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0443r14.html).

Можно увидеть, что:

- Пул потоков – это лишь один (хоть и важный) из компонентов сложной инфраструктуры экзекуторов.
- У пула потоков есть отдельные методы `schedule` и `execute`.

## Задание

1) Реализуйте [блокирующую очередь](tp/blocking_queue.hpp)
2) Реализуйте [статический пул потоков](tp/static_thread_pool.hpp)

Изучите юнит-тесты очереди и пула потоков чтобы разобраться с их поведением.

Вы можете добавлять в библиотеку `tp` новые файлы!

## Замечания по реализации

### `Join`

Блокирующую остановку с ожиданием завершения задач можно реализовать разными способами, постарайтесь найти наиболее изящный вариант.

### Деструктор

Напишите `assert` в деструктор на случай забытого вызова `Join` / `Shutdown`.

### `thread_local`

Задача тестируется под файберами, поэтому реализовать функцию `tp::Current` через [`thread_local`](https://en.cppreference.com/w/cpp/keyword/thread_local) указатель на пул мы не можем.

Вместо `thread_local` мы будем использовать класс `twist::util::ThreadLocal<T>`.
