# Future

Напишите аналог [`std::future`](https://en.cppreference.com/w/cpp/thread/future).

## Blocking Futures

`Future<T>` / `Promise<T>` образуют "канал" для возврата результата из асинхронной операции.

_Результат_ – значение типа `T` или исключение.

`Promise<T>` – конец канала для записи, предоставляет два метода: `SetValue` для передачи значения и `SetException` для передачи исключения.

`Future<T>` – конец канала для чтения, предоставляет единственный метод `Get`, который блокирует поток до тех пор, пока через `Promise` не будет отправлен результат.  

Канал – _одноразовый_: вызвать `SetValue` / `SetException` на `Promise` и `Get` на `Future` можно только один раз, в противном случае – UB.

## Пример

```cpp
// Пул потоков для вычислений
tp::StaticThreadPool thread_pool{/*workers=*/4};

// Создаем "контракт"
stdlike::Promise<int> p;
auto f = p.MakeFuture();

thread_pool.Submit([p = std::move(p)]() mutable {
  std::this_thread::sleep_for(3s);  // <-- Тут можно представить тяжелое вычисление
  p.SetValue(42);  // <-- "Возвращаем" значение, "исполняем контракт"
});

int value = f.Get();  // <-- Дожидаемся значения
```

## Disclaimer

В этой задаче мы рассматриваем только наивные блокирующие фьючи, в том виде, в котором они представлены в `std`.

## Указания по реализации

Используйте [`std::variant`](https://en.cppreference.com/w/cpp/utility/variant) для представления результата (значения / исключения)

Используйте [`std::exception_ptr`](https://en.cppreference.com/w/cpp/error/exception_ptr) для того, чтобы переносить исключения между потоками.

В этой задаче вы можете создавать новые файлы в библиотеке `futures`.

Дополнительные классы, которые представляют собой детали реализации и которые пользователь не должен использовать напрямую, спрячьте их во вложенное пространство имен `stdlike::detail`.
