# `SleepFor`

Вам даны однопоточные файберы с примитивной реализацией функции `SleepFor`:

```cpp
void Scheduler::SleepFor(Duration delay) {
  StopWatch stop_watch;
  do {
    Yield();
  } while (stop_watch.Elapsed() < delay);
}
````

Как видно, файбер в вызове `SleepFor` вовсе не спит, а постоянно перепланируется, вхолостую растрачивая процессорное время.

Вы должны реализовать `SleepFor` эффективнее: спящий файбер не должен постоянно получать управление и перепланироваться, планировщик не должен тратить на него процессорное время.

Если в планировщике нет файберов, которые готовы исполняться, но при этом есть спящие файберы, то планировщик должен блокировать _поток_, в котором он (планировщик) запущен, до пробуждения первого файбера.

## Внешний мир / `asio`

Пока файберы умеют лишь запускаться и перепланироваться. Время – это первый повод для взаимодействия файберов с внешним миром. 

Это взаимодействие мы будем осуществлять с помощью библиотеки [`asio`](https://think-async.com/Asio/asio-1.18.1/doc/asio/overview/rationale.html), которая предоставляет унифицированные асинхронные интерфейсы для работы с таймерами и сетью.

После реализации `SleepFor` можно будет научить файберы сетевому I/O.

## Реализация

Используйте таймеры и event loop (`io_context`) из библиотеки `asio`.

### Таймеры

Прочтите tutorial по таймерам:  [Using a timer asynchronously](http://think-async.com/Asio/asio-1.18.1/doc/asio/tutorial/tuttimer2.html).

Используйте специализацию `WaitableTimer`, определенную в [timer.hpp](tinyfibers/runtime/timer.hpp).

Запрещается:
- использовать функции [std::this_thread::sleep_for](https://en.cppreference.com/w/cpp/thread/sleep_for) и [sleep](http://man7.org/linux/man-pages/man3/sleep.3.html), т.е. явно ставить поток на паузу,
- писать свои собственные очереди спящих потоков.

### Два цикла

Для использования `asio` в файберах вам потребуется сочетать итерации двух циклов:

1) Цикл запуска файберов, который находится в методе `RunLoop` планировщика
2) Цикл обработки событий / запуска обработчиков `asio`: `io_context::run`

Подумайте, итерации какого из этих циклов стоит подчинить другому.

Реализация `RunLoop` в вашем коде должна упроститься!

## Синхронная асинхронность

Главное содержание задачи – с помощью переключений контекста научиться клеить разорванный асинхронными вызовами поток управления. 

## Точка зрения

С одной стороны, в задаче мы расширяем функциональность файберов с помощью `asio`.

Но можно смотреть на задачу иначе – мы хотим построить синхронный API для библиотеки `asio`, и используем файберы как средство выразительности.
