# Mutex

## Пререквизиты

- [fibers/yield](/tasks/fibers/coroutine)
- [fibers/sleep_for](/tasks/fibers/sleep_for)
- [cond/condvar](/tasks/cond/condvar)
- [cond/wait_group](tasks/cond/wait_group)
- [tasks/executors](/tasks/tasks/executors) + интрузивность – рекомендуется

---

Реализуйте примитивы синхронизации для файберов:
- [`Event`](exe/fibers/sync/event.hpp)
- [`Mutex`](exe/fibers/sync/mutex.hpp)
- [`WaitGroup`](exe/fibers/sync/wait_group.hpp)

Методы `Event::Wait`, `Mutex::Lock` и `WaitGroup::Wait` должны останавливать файбер, но не должны блокировать поток планировщика, в котором этот файбер исполняется.

## Пример

```cpp
void SyncExample() {
  using namespace exe;
  
  executors::ThreadPool scheduler{/*threads=*/4};
  scheduler.Start();
  
  fibers::Go(scheduler, []() {
    fibers::Mutex mutex;
    size_t cs = 0;
    
    // https://gobyexample.com/waitgroups
    // Будем считать, что WaitGroup одноразовый, т.е. счетчик
    // опускается до нуля только один раз.
    fibers::WaitGroup wg;
    
    wg.Add(123);
    
    for (size_t i = 0; i < 123; ++i) {
      fibers::Go([&] {
        // При выходе из скоупа будет вызван wg.Done()
        // https://gobyexample.com/defer
        wheels::Defer defer([&wg] {
          wg.Done();
        });
        
        for (size_t j = 0; j < 1024; ++j) {
          std::lock_guard guard(mutex);
          ++cs;  // <-- в критической секции
        }
      });
    }
    
    // Дожидаемся завершения запущенных файберов
    wg.Wait();
    
    fmt::println("# critical sections: {}", cs);
    // <-- Напечатано 123 * 1024
  });
  
  scheduler.WaitIdle();
  scheduler.Stop();
}
```

## `Suspend`

### Сценарии

Остановка файбера для ожидания на примитиве синхронизации – лишь частный случай общего сценария: файберу нужно остановиться и запланировать свое возобновление при наступлении некоторого события.

Планирование возобновления зависит от конкретного примитива / операции:

- `Mutex::Lock`: запланировать возобновление – значит положить себя в очередь ожидания, из которой нас потом достанет и запланирует на исполнение другой файбер в вызове `Mutex::Unlock`.
- `Yield`: сразу же отправить себя в планировщик
- `SleepFor`: запланировать себя по готовности таймера  
- `Await(Future)`: запланировать возобновление – значит подписаться на готовность `Future`, которая запланирует нас по готовности результата.
- и т.д.

В этой задаче мы хотим придумать универсальный `Suspend`, который подойдет для каждого из приведенных сценариев и позволит пользователям добавлять новые примитивы / операции синхронизации, не меняя при этом ядро файберов.

### Awaiters

Решение – кастомизировать для `Suspend` планирование возобновления файбера с помощью внешней (по отношению к файберу) стратегии, которую определяет конкретный примитив синхронизации / операция.

Эту стратегию мы назовем _Awaiter_.

_Awaiter_ в методе `AwaitSuspend` решает когда именно уже **остановленный** файбер должен возобновить свое исполнение.

[Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

### `FiberHandle`

Awaiter работает с остановленным файбером не напрямую, а через объект [`FiberHandle`](exe/fibers/core/handle.hpp).

Экземпляр `FiberHandle` представляет **остановленный** файбер.

Запустить его можно двумя способами:
- `Schedule`: запланировать в планировщик
- `Resume`: возобновить немедленно прямо на текущем потоке

Непрозрачный `FiberHandle` позволяет 
- Избавиться в реализации примитивов синхронизации от непосредственного доступа к объекту `Fiber`, скрыть его от пользователя
- Избавить `Fiber` от знания про примитивы / операции синхронизации

FiberHandle – _TriviallyCopyable_, передавайте его по значению.

## `Yield`

Выразите `Yield` через `Suspend`. 

В классе `Fiber` не должно быть никаких следов `Yield`.

Так вы убедитесь, что получившийся `Suspend` подходит для разных задач синхронизации.

## Аллокации

### `Yield`

Метод `Yield`, реализованный через `Suspend`, должен обходиться без динамических аллокаций памяти.

Заворачивание лямбды в `std::function` или подобный контейнер с type erasure – тоже динамическая аллокация.

### `Mutex`

В реализации `Mutex`, `Event` и `WaitGroup` вам потребуются очереди ожидания.

Реализуйте их без динамических аллокаций памяти, через интрузивные списки: [`wheels::IntrusiveList`](https://gitlab.com/Lipovsky/wheels/-/tree/master/wheels/intrusive/list.hpp) или собственный список для lock-free реализации.

Подумайте, какая сущность в вашем дизайне лучше всего подходит на роль узла интрузивного списка.

### Задачи

Бонусный уровень!

Реализуйте экзекуторы с интрузивными задачами в [tasks/executors](/tasks/tasks/executors) и перенесите их сюда.

### Итого

Если ваша реализация планировщика поддерживает интрузивные задачи, то единственными динамическими аллокациями в рантайме файберов окажутся аллокации самого объекта `Fiber`.

## Синхронизация

### Fiber

В классе `Fiber` не должно быть дополнительной синхронизации: ни взаимного исключения, ни ожидания других потоков.

### Lock-free

Бонусный уровень!

Напишите лок-фри реализацию примитивов синхронизации, без использования взаимного исключения.

Для этого вам потребуется расширить контракт `AwaitSuspend`.

## Symmetric Transfer

Бонусный уровень!

Прочитайте про симметричную передачу управления в корутинах из C++20.

Реализуйте симметричную передачу управления в файберах, минуя планировщик. Для этого вам еще раз потребуется расширить контракт `AwaitSuspend`.

Пройдите тестовую цель `fibers_mutex_unit_extra_tests`.

## Considered Harmful

Не меняйте API пула потоков, файберы для планирования полагаются только на `Submit`.

В `core` не должны проникать детали реализации конкретных примитивов синхронизации: спинлоки, списки и т.п.
