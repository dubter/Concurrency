# Мьютекс

Реализуйте мьютекс ([`Mutex`](mtf/fibers/sync/mutex.hpp)) и условную переменную ([`CondVar`](mtf/fibers/sync/condvar.hpp)) для файберов.

Методы `Mutex::Lock` и `CondVar::Wait` должны блокировать только вызывающий их файбер, но не блокировать поток.

## `FutexLike`

Реализация самого мьютекса и условной переменной не будет отличаться от реализации этих же примитивов для потоков, вы можете позаимствовать алгоритмы из уже решенных задач.

Но в этот раз у вас не будет фьютекса, для файберов его придется реализовать самостоятельно.

Реализуйте класс [`FutexLike<T>`](mtf/fibers/sync/futex.hpp) – атомик с дополнительными операциями `ParkIfEqual` и `WakeOne` / `WakeAll`.

Семантика `ParkIfEqual(T old)` – атомарно (относительно конкурирующих вызовов `WakeOne` / `WakeAll`) проверить, что значение атомика равно `old` и запарковать текущий _файбер_ в очереди ожидания.

## Реализация

### Интерфейс для блокирующего ожидания

Вы увидите, что для реализации многопоточных файберов недостаточно иметь "системный вызов" `Suspend`, вам потребуется расширить его сигнатуру.

Возможно, вам помогут идеи из корутин С++ и концепт `Awaiter`, особенно метод `await_suspend`. 
См. [C++ Coroutines: Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

Код, написанный вами в `mtf/fibers/core`, должен быть достаточно универсален и пережить без изменений реализацю канала.

### Динамические аллокации

В реализации фьютекса не должно быть дополнительных аллокаций. Используйте интрузивные списки и аллокацию на стеке.

Реализация блокирующего ожидания также должна избегать дополнительных аллокаций. Использование `std::function` или аналогичного контейнера для type erasure – это тоже скрытая аллокация.