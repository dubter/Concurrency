# Мьютекс

## Пререквизиты

- [fibers/coroutine](/tasks/fibers/coroutine)
- [mutex/mutex](/tasks/mutex/mutex)
- [condvar/condvar](/tasks/condvar/condvar)

---

Реализуйте мьютекс ([`Mutex`](mtf/fibers/sync/mutex.hpp)) и условную переменную ([`CondVar`](mtf/fibers/sync/condvar.hpp)) для файберов.

Методы `Mutex::Lock` и `CondVar::Wait` должны блокировать только вызывающий их файбер, но не блокировать поток.

## `FutexLike`

Реализация самого мьютекса и условной переменной не будет отличаться от реализации этих же примитивов для потоков, вы можете позаимствовать алгоритмы из уже решенных задач.

Но в этот раз у вас не будет фьютекса, для файберов его придется реализовать самостоятельно.

Реализуйте класс [`FutexLike<T>`](mtf/fibers/sync/futex.hpp) – атомик с дополнительными операциями `ParkIfEqual` и `WakeOne` / `WakeAll`.

Семантика `ParkIfEqual(T old)` – атомарно (относительно конкурирующих вызовов `WakeOne` / `WakeAll`) сравнить текущее значение атомика с `old` и в случае равенства запарковать текущий _файбер_ в очереди ожидания.

## Реализация

### `Suspend`

Вы увидите, что для реализации многопоточных файберов недостаточно иметь "системный вызов" `Suspend()`, вам потребуется расширить его сигнатуру.

Возможно, вам помогут идеи из корутин С++, концепт `Awaiter` с методом `await_suspend`. 
См. [C++ Coroutines: Understanding operator co_await](https://lewissbaker.github.io/2017/11/17/understanding-operator-co-await)

Код, написанный вами в [`fibers/core`](mtf/fibers/core), должен быть достаточно универсален: в нем не должно быть знания про фьютексы и спинлоки, этот код должен пережить без изменений реализацию канала.

### `SubmitContinuation`

Использовать метод `SubmitContinuation` у `StaticThreadPool` нельзя, гонку между остановкой файбера и планированием его возобновления нужно решить самостоятельно на уровне API `Suspend`.

### Динамические аллокации

В реализации фьютекса не должно быть дополнительных аллокаций. Используйте интрузивные списки и аллокацию узлов на стеке.

Реализация блокирующего ожидания также должна избегать дополнительных аллокаций. Использование `std::function` или аналогичного контейнера для type erasure – это тоже скрытая аллокация.

### Разное

Убедитесь, что к пользователю, который инклудит заголовочный файл `mtf/fibers/sync/mutex.hpp`, не попадет объявление класса `Fiber`.

Для этого в реализации `FutexLike<T>` используйте `Suspend` и `FiberHandle`.
