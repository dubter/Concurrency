# SleepFor

Пока файберы из `exe` умеют лишь запускаться и перепланироваться. 

В этой задаче мы научим файберы спать.

## Event Loop

Мы поменяем планировщик: теперь это будет не пул потоков, а `asio::io_context` – [_event loop_](https://www.youtube.com/watch?v=8aGhZQkoFbQ) из библиотеки [`asio`](https://think-async.com/).

`io_context` планирует таймеры и операции ввода-вывода над сокетами + пользовательские _обработчики_ (_handler_) или _коллбэки_ (_callback_).

### `post` 

С помощью свободной функции `post` можно запланировать в `io_context` исполнение произвольной лямбды: 

```cpp
void PostExample() {
  // Планировщик I/O
  asio::io_context io;
    
  // Планируем задачу на исполнение
  // Аналогично `tp::Submit`
  asio::post(io, []() {
    // Этот код будет вызван из цикла io_context::run
    std:::cout << "Hi" << std::endl;
  });
  
  // Планировщик использует для работы текущий поток
  // Вызов run вернет управление тогда, когда в планировщике
  // не останется ни пользовательских обработчиков, 
  // ни outstanding асинхронных операций / таймеров
  io.run();
  // <-- На экране напечатано Hi
  
  // Планировщик запускает единственную задачу, работа в нем 
  // заканчивается, он автоматически останавливается
}
```

### Таймеры

[Using a timer asynchronously](https://think-async.com/Asio/asio-1.22.1/doc/asio/tutorial/tuttimer2.html)

```cpp
void TimerExample() {
  // Event loop, планировщик I/O
  asio::io_context io;
  
  // Таймер – I/O object
  // Привязываем его к планировщику
  asio::steady_timer timer(io);
  
  // Заводим таймер
  timer.expires_after(3s);
  
  // "Подвешиваем" к таймеру обработчик
  // NB: таймер должен "дожить" до завершения асинхронной операции! н
  timer.async_wait([](std::error_code /*ec*/) {
    // Обработчик будет вызван из цикла io_context::run
    std::cout << "Hi" << std::endl;
  });
  
  // Прямо сейчас исполнять нечего, но в планировщике есть 
  // заведенный таймер
  // Поток блокируется на 3 секунды, затем срабатывает таймер, 
  // который приводит к запуску обработчика
  io.run();
  // <-- На экране напечатано Hi
  
  // После срабатывания таймера и запуска обработчика
  // планировщик останавливается, в нем больше не осталось работы
}
```

### Потоки

Метод `run` на `io_context` можно вызывать из нескольких потоков. В таком случае пользовательские обработчики смогут запускаться параллельно.

## Пул потоков / event loop

- В пуле потоков воркеры блокируются на общей очереди задач.
- В event loop поток блокируется на системной очереди событий (например, на `epoll`).

## `SleepFor`

Мы хотим поддержать в файберах из `exe` первый блокирующий вызов – `SleepFor`.

```cpp
void SleepForExample() {
  using namespace exe;
  
  // Планировщик для файберов
  asio::io_context scheduler;
  
  fibers::Go(scheduler, []() {
    for (size_t i = 0; i < 10; ++i) {
      std::cout << i << std::endl;
      // Файбер блокируется на 1 секунду, но
      // не блокирует цикл планировщика
      fibers::self::SleepFor(1s);
    }
  });
  
  // Автоматически завершится через 10 секунд
  scheduler.run();
}
```

## Задание

1) Адаптируйте файберы к новому планировщику
2) Реализуйте `SleepFor`

## Указания по реализации

В реализации файберов не должно быть блокирующего поток ожидания.

Подумайте над тем, где разместить объект таймера для `SleepFor`.

## Asio

* [Github](https://github.com/chriskohlhoff/asio/)
* [Basic Anatomy](https://think-async.com/Asio/asio-1.22.1/doc/asio/overview/basics.html)
* [Overview](https://think-async.com/Asio/asio-1.22.1/doc/asio/overview.html)
* [Tutorial](https://think-async.com/Asio/asio-1.22.1/doc/asio/tutorial.html)