# Мьютекс

В этой задаче вы должны реализовать [std::mutex](https://ru.cppreference.com/w/cpp/thread/mutex). 

Отличие мьютекса от спинлока в том, что мьютекс _блокирует_ поток, который ожидает захвата блокировки.

Требования:

* Захват и освобождение мьютекса, на владение которым больше никто не претендует, должен происходить максимально быстро, без переключения в ядро операционной системы..

* Если поток не может захватить блокировку, потому что его опережают другие потоки (такую ситуацию называют _contention_), то он должен _заблокироваться_ до освобождения мьютекса и освободить процессор.

Шаблон решения – [`mutex.hpp`](mutex.hpp).

## Фьютекс

Реализовать блокировку потока операционной системы целиком в пространстве пользователя невозможно, за исполнение потока отвечает планировщик операционной системы.

За пользовательские блокировки в Linux отвечает _futex_ – ядерная очередь спящих потоков, которая привязана к ячейке памяти в адресном пространстве пользователя.

Пользователь работает с фьютексом через одноименный системный вызов – [futex(2)](http://man7.org/linux/man-pages/man2/futex.2.html).

- [futex(2)](http://man7.org/linux/man-pages/man2/futex.2.html)
- [Basics of Futexes](https://eli.thegreenplace.net/2018/basics-of-futexes/)
- [kernel/futex.c](https://github.com/torvalds/linux/blob/master/kernel/futex.c)

## `atomic::wait`

Начиная с С++20, с фьютексом можно работать через методы атомиков: [`wait`](https://en.cppreference.com/w/cpp/atomic/atomic/wait) + `notify_one` / `notify_all`

Изучите документацию этих методов!

Можно считать, что вызовы `wait` и `notify_{one,all}` - атомарны относительно друг друга: в ядре при работе с фьютексом берется ядерный спинлок.

При этом `wait` нельзя считать атомарным относительно вызова `store`!

### Реализация в стандартной библиотеке

- [libc++](https://github.com/llvm/llvm-project/blob/main/libcxx/src/atomic.cpp)
- [libstdc++](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/atomic_wait.h)

## Ограничения

Фьютекс работает только с 32-битными словами в пространстве пользователя, так что используйте в реализации `atomic<uint32_t>`.

## Проверка в `atomic::wait`

Может показаться, что аргумент `old` и проверка в [`atomic::wait`](https://en.cppreference.com/w/cpp/atomic/atomic/wait) – избыточны, и было бы достаточно иметь лаконичный `wait` без аргументов.

Проведите эксперимент: решите задачу используя для блокирующего ожидания класс [`WaitQueue`](wait_queue.hpp) с методами `Park` и `WakeOne` / `WakeAll`. 
